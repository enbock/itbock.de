interface ServiceWorkerEventMap {
    'activate': ExtendableEvent;
    'fetch': FetchEvent;
    'install': InstallEvent;
    'waiting': ExtendableEvent;
}

interface ServiceWorkerGlobalScope {
    readonly caches: CacheStorage;

    addEventListener<K extends keyof ServiceWorkerEventMap>(
        type: K,
        listener: (event: ServiceWorkerEventMap[K]) => any,
        useCapture?: boolean
    ): void;

    skipWaiting(): void;
}

interface InstallEvent extends ExtendableEvent {
    readonly activeWorker: ServiceWorker;
}

interface ExtendableEvent extends Event {
    waitUntil(promise: Promise<any>): void;
}

interface FetchEvent extends Event {
    readonly isReload: boolean;
    readonly request: Request;
    readonly clientId: string;

    respondWith(all: any): Response;
}

// https://developers.google.com/web/fundamentals/primers/service-workers
class ServiceWorkerManager {
    constructor(
        private worker: ServiceWorkerGlobalScope,
        private caches: CacheStorage,
        private version: string,
        private fileList: string[]
    ) {
        this.worker.addEventListener('install', this.installCache.bind(this));
        this.worker.addEventListener('activate', this.activateCache.bind(this));
        this.worker.addEventListener('fetch', this.fetchRequest.bind(this));
    }

    installCache(event: InstallEvent) {
        this.worker.skipWaiting(); // No wait, content immediately active (even partially)
        event.waitUntil(this.cacheFiles());
    }

    activateCache(event: ExtendableEvent) {
        event.waitUntil(this.clearOldCaches());
    }

    fetchRequest(event: FetchEvent) {
        event.respondWith(this.fetch(event.request));
    }

    async cacheFiles() {
        const cache: Cache = await this.caches.open(this.version);
        return cache.addAll(this.fileList);
    }

    async clearOldCaches() {
        const cacheNames = await this.caches.keys();

        return Promise.all(
            cacheNames.map(
                (cacheName: string) => {
                    if (cacheName != this.version) {
                        return this.caches.delete(cacheName);
                    }
                }
            )
        );
    }

    async fetch(request: Request) {
        const response: Response | undefined = await this.caches.match(request);

        if (response) {
            return response;
        }

        const fetchResponse: Response = await fetch(request);
        if (!fetchResponse || fetchResponse.status !== 200 || fetchResponse.type !== 'basic') {
            return fetchResponse;
        }

        // IMPORTANT: Clone the response. A response is a stream
        // and because we want the browser to consume the response
        // as well as the cache consuming the response, we need
        // to clone it so we have two streams.
        const responseToCache: Response = fetchResponse.clone();

        const cache: Cache = await this.caches.open(this.version);
        await cache.put(request, responseToCache);

        return fetchResponse;
    }
}

const version: string = 'VERSION'; // Will be generated by script
const fileList: string[] = []; // Will be generated by script
try {
    if (process.env.NODE_ENV !== 'testing') {
        throw new Error('Can be run now...');
    }
} catch {
    console.log('Create service worker...');
    new ServiceWorkerManager(
        <ServiceWorkerGlobalScope><unknown>this,
        caches,
        version,
        fileList
    );
}
